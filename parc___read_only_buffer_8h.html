<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>PARC Library: /Users/gscott/Documents/workspace/CCNx_Distillery/src/Libparc/parc/algol/parc_ReadOnlyBuffer.h File Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="masthead.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="masthead.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxygen-bootstrap.js"></script>
    </head>
    <body>
        <div class="container masthead">
          <div class="navbar-header">
            <img src="parc_black_solid.png" \>
          </div>
        </div>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">PARC Library </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Public&#160;Types</span></a></li>
      <li><a href="globals.html"><span>Global&#160;Entities</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_7f9df3ca38d861d94088e98ccd293ed1.html">Libparc</a></li><li class="navelem"><a class="el" href="dir_32724a6363975856e5331f5a8cd1be3e.html">parc</a></li><li class="navelem"><a class="el" href="dir_93537ef564b672990ae767cc40b664ef.html">algol</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">parc_ReadOnlyBuffer.h File Reference<div class="ingroups"><a class="el" href="group__memory.html">Memory and Buffer Management</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An indexable, linear buffer of read-only bytes.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An indexable, linear buffer of read-only bytes. </p>
<p>A <code>PARCReadOnlyBuffer</code> is a <a class="el" href="">PARCBuffer</a> that cannot be modified, but retains a position, limit and capacity.</p>
<dl class="section author"><dt>Author</dt><dd>Glenn Scott, Palo Alto Research Center (Xerox PARC) </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2013-2014, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC). All rights reserved. </dd></dl>
</div><div class="textblock"><code>#include &lt;<a class="el" href="parc___buffer_8h_source.html">parc/algol/parc_Buffer.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="parc___byte_array_8h_source.html">parc/algol/parc_ByteArray.h</a>&gt;</code><br />
</div>
<p><a href="parc___read_only_buffer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5873c15cfe65b95677ea4f18204178a9"><td class="memItemLeft" align="right" valign="top">PARCReadOnlyBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a5873c15cfe65b95677ea4f18204178a9">parcReadOnlyBuffer_Create</a> (PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a5873c15cfe65b95677ea4f18204178a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of <code>PARCBuPARCReadOnlyBuffer</code> referencing the content of the given <a class="el" href="">PARCBuffer</a>.  <a href="#a5873c15cfe65b95677ea4f18204178a9">More...</a><br /></td></tr>
<tr class="separator:a5873c15cfe65b95677ea4f18204178a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587c7811d8650888fd517d4108d60b90"><td class="memItemLeft" align="right" valign="top">PARCReadOnlyBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a587c7811d8650888fd517d4108d60b90">parcReadOnlyBuffer_Wrap</a> (uint8_t *array, size_t arrayLength, size_t position, size_t limit)</td></tr>
<tr class="memdesc:a587c7811d8650888fd517d4108d60b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of <code>PARCReadOnlyBuffer</code> using program supplied memory.  <a href="#a587c7811d8650888fd517d4108d60b90">More...</a><br /></td></tr>
<tr class="separator:a587c7811d8650888fd517d4108d60b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d6f03abb7c55a53ad7ed8b1cd64a88"><td class="memItemLeft" align="right" valign="top">PARCReadOnlyBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a96d6f03abb7c55a53ad7ed8b1cd64a88">parcReadOnlyBuffer_Acquire</a> (const PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:a96d6f03abb7c55a53ad7ed8b1cd64a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the number of references to a <code>PARCReadOnlyBuffer</code>.  <a href="#a96d6f03abb7c55a53ad7ed8b1cd64a88">More...</a><br /></td></tr>
<tr class="separator:a96d6f03abb7c55a53ad7ed8b1cd64a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8828c20c01777b8502abe6f4ff9c206c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a8828c20c01777b8502abe6f4ff9c206c">parcReadOnlyBuffer_Release</a> (PARCReadOnlyBuffer **bufferPtr)</td></tr>
<tr class="memdesc:a8828c20c01777b8502abe6f4ff9c206c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a <code>PARCReadOnlyBuffer</code> reference.  <a href="#a8828c20c01777b8502abe6f4ff9c206c">More...</a><br /></td></tr>
<tr class="separator:a8828c20c01777b8502abe6f4ff9c206c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d6ab918f02b0a7dabb8cf3b2e35de6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a25d6ab918f02b0a7dabb8cf3b2e35de6">parcReadOnlyBuffer_Capacity</a> (const PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:a25d6ab918f02b0a7dabb8cf3b2e35de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this buffer's capacity.  <a href="#a25d6ab918f02b0a7dabb8cf3b2e35de6">More...</a><br /></td></tr>
<tr class="separator:a25d6ab918f02b0a7dabb8cf3b2e35de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec31d44124e22f3c258ceb89899c7860"><td class="memItemLeft" align="right" valign="top">PARCReadOnlyBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#aec31d44124e22f3c258ceb89899c7860">parcReadOnlyBuffer_Clear</a> (PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:aec31d44124e22f3c258ceb89899c7860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the given buffer: The position is set to zero, the limit is set to the capacity, and the mark is invalidated.  <a href="#aec31d44124e22f3c258ceb89899c7860">More...</a><br /></td></tr>
<tr class="separator:aec31d44124e22f3c258ceb89899c7860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318303e625fdf7786e1a0580f57fa6e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a318303e625fdf7786e1a0580f57fa6e7">parcReadOnlyBuffer_Equals</a> (const PARCReadOnlyBuffer *x, const PARCReadOnlyBuffer *y)</td></tr>
<tr class="memdesc:a318303e625fdf7786e1a0580f57fa6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two <code>PARCReadOnlyBuffer</code> instances are equal.  <a href="#a318303e625fdf7786e1a0580f57fa6e7">More...</a><br /></td></tr>
<tr class="separator:a318303e625fdf7786e1a0580f57fa6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc28820e8b78321659d98fdfc4c19f1e"><td class="memItemLeft" align="right" valign="top">PARCByteArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#adc28820e8b78321659d98fdfc4c19f1e">parcReadOnlyBuffer_Array</a> (const PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:adc28820e8b78321659d98fdfc4c19f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the <a class="el" href="">PARCByteArray</a> that backs this buffer.  <a href="#adc28820e8b78321659d98fdfc4c19f1e">More...</a><br /></td></tr>
<tr class="separator:adc28820e8b78321659d98fdfc4c19f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5440e5af26d0b31984399978e1effd"><td class="memItemLeft" align="right" valign="top">PARCReadOnlyBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a3c5440e5af26d0b31984399978e1effd">parcReadOnlyBuffer_Copy</a> (const PARCReadOnlyBuffer *original)</td></tr>
<tr class="memdesc:a3c5440e5af26d0b31984399978e1effd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the given <code>PARCReadOnlyBuffer</code>.  <a href="#a3c5440e5af26d0b31984399978e1effd">More...</a><br /></td></tr>
<tr class="separator:a3c5440e5af26d0b31984399978e1effd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c569ce138aa1854ca1d4b4045e9074d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a0c569ce138aa1854ca1d4b4045e9074d">parcReadOnlyBuffer_ArrayOffset</a> (const PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:a0c569ce138aa1854ca1d4b4045e9074d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset within this buffer's backing <a class="el" href="">PARCByteArray</a> of the first element.  <a href="#a0c569ce138aa1854ca1d4b4045e9074d">More...</a><br /></td></tr>
<tr class="separator:a0c569ce138aa1854ca1d4b4045e9074d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6869292dc3368d740a53e5f73ab83ab4"><td class="memItemLeft" align="right" valign="top">PARCReadOnlyBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a6869292dc3368d740a53e5f73ab83ab4">parcReadOnlyBuffer_Rewind</a> (PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:a6869292dc3368d740a53e5f73ab83ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewinds this <code>PARCReadOnlyBuffer</code>: The position is set to zero and the mark is invalidated.  <a href="#a6869292dc3368d740a53e5f73ab83ab4">More...</a><br /></td></tr>
<tr class="separator:a6869292dc3368d740a53e5f73ab83ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc7e08324fdf8277a198b7523727e7d"><td class="memItemLeft" align="right" valign="top">PARCReadOnlyBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a7bc7e08324fdf8277a198b7523727e7d">parcReadOnlyBuffer_Reset</a> (PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:a7bc7e08324fdf8277a198b7523727e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the given <code>PARCReadOnlyBuffer</code>'s position to the previously-marked position.  <a href="#a7bc7e08324fdf8277a198b7523727e7d">More...</a><br /></td></tr>
<tr class="separator:a7bc7e08324fdf8277a198b7523727e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b24a3b835275a610c7693ea49fc422b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a6b24a3b835275a610c7693ea49fc422b">parcReadOnlyBuffer_Limit</a> (const PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:a6b24a3b835275a610c7693ea49fc422b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the given <code>PARCReadOnlyBuffer</code>'s limit.  <a href="#a6b24a3b835275a610c7693ea49fc422b">More...</a><br /></td></tr>
<tr class="separator:a6b24a3b835275a610c7693ea49fc422b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eea1d4192f49da754d0e4a2d099916e"><td class="memItemLeft" align="right" valign="top">PARCReadOnlyBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a3eea1d4192f49da754d0e4a2d099916e">parcReadOnlyBuffer_Mark</a> (PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:a3eea1d4192f49da754d0e4a2d099916e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this buffer's mark at its position.  <a href="#a3eea1d4192f49da754d0e4a2d099916e">More...</a><br /></td></tr>
<tr class="separator:a3eea1d4192f49da754d0e4a2d099916e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc5e29414e66c562cdbd520429d7b7a"><td class="memItemLeft" align="right" valign="top">PARCReadOnlyBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a5bc5e29414e66c562cdbd520429d7b7a">parcReadOnlyBuffer_SetLimit</a> (PARCReadOnlyBuffer *buffer, size_t newLimit)</td></tr>
<tr class="memdesc:a5bc5e29414e66c562cdbd520429d7b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this <code>PARCReadOnlyBuffer</code>'s limit.  <a href="#a5bc5e29414e66c562cdbd520429d7b7a">More...</a><br /></td></tr>
<tr class="separator:a5bc5e29414e66c562cdbd520429d7b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913e6dc56f8c73d3df521135a154b4d6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a913e6dc56f8c73d3df521135a154b4d6">parcReadOnlyBuffer_Overlay</a> (PARCReadOnlyBuffer *buffer, size_t length)</td></tr>
<tr class="memdesc:a913e6dc56f8c73d3df521135a154b4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to memory that can be cast to a specific type.  <a href="#a913e6dc56f8c73d3df521135a154b4d6">More...</a><br /></td></tr>
<tr class="separator:a913e6dc56f8c73d3df521135a154b4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258dc7660b1640b40a161d2be5eace8a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a258dc7660b1640b40a161d2be5eace8a">parcReadOnlyBuffer_Position</a> (const PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:a258dc7660b1640b40a161d2be5eace8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the given <code>PARCReadOnlyBuffer</code>'s position.  <a href="#a258dc7660b1640b40a161d2be5eace8a">More...</a><br /></td></tr>
<tr class="separator:a258dc7660b1640b40a161d2be5eace8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efd568d40d46f93c0069e3403ec00d1"><td class="memItemLeft" align="right" valign="top">PARCReadOnlyBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a5efd568d40d46f93c0069e3403ec00d1">parcReadOnlyBuffer_SetPosition</a> (PARCReadOnlyBuffer *buffer, size_t newPosition)</td></tr>
<tr class="memdesc:a5efd568d40d46f93c0069e3403ec00d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the given <code>PARCReadOnlyBuffer</code>'s position.  <a href="#a5efd568d40d46f93c0069e3403ec00d1">More...</a><br /></td></tr>
<tr class="separator:a5efd568d40d46f93c0069e3403ec00d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15d1a5859b9b87f9905bbfe7a45df00"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#af15d1a5859b9b87f9905bbfe7a45df00">parcReadOnlyBuffer_Remaining</a> (const PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:af15d1a5859b9b87f9905bbfe7a45df00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements between the current position and the limit.  <a href="#af15d1a5859b9b87f9905bbfe7a45df00">More...</a><br /></td></tr>
<tr class="separator:af15d1a5859b9b87f9905bbfe7a45df00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf5417af111da7901cda352758f0aa0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#afbf5417af111da7901cda352758f0aa0">parcReadOnlyBuffer_HasRemaining</a> (const PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:afbf5417af111da7901cda352758f0aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether there are any elements between the current position and the limit.  <a href="#afbf5417af111da7901cda352758f0aa0">More...</a><br /></td></tr>
<tr class="separator:afbf5417af111da7901cda352758f0aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af186ebea64d92ca9d2d3cd2508a69b89"><td class="memItemLeft" align="right" valign="top">PARCReadOnlyBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#af186ebea64d92ca9d2d3cd2508a69b89">parcReadOnlyBuffer_GetArray</a> (PARCReadOnlyBuffer *buffer, uint8_t *array, size_t length)</td></tr>
<tr class="memdesc:af186ebea64d92ca9d2d3cd2508a69b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the limit to the current position, then set the position to zero.  <a href="#af186ebea64d92ca9d2d3cd2508a69b89">More...</a><br /></td></tr>
<tr class="separator:af186ebea64d92ca9d2d3cd2508a69b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d23a06e0adb3e7aab3f0ab0d72e88d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a02d23a06e0adb3e7aab3f0ab0d72e88d">parcReadOnlyBuffer_GetUint8</a> (PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:a02d23a06e0adb3e7aab3f0ab0d72e88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the single <code>uint8_t</code> at the current buffer position.  <a href="#a02d23a06e0adb3e7aab3f0ab0d72e88d">More...</a><br /></td></tr>
<tr class="separator:a02d23a06e0adb3e7aab3f0ab0d72e88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fce2c9d774159fb9dfff895b9c0e3c1"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a3fce2c9d774159fb9dfff895b9c0e3c1">parcReadOnlyBuffer_GetUint16</a> (PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:a3fce2c9d774159fb9dfff895b9c0e3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the single <code>uint16_t</code> at the current buffer position.  <a href="#a3fce2c9d774159fb9dfff895b9c0e3c1">More...</a><br /></td></tr>
<tr class="separator:a3fce2c9d774159fb9dfff895b9c0e3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75131fd493a8fd16617af7210c3f5fbd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a75131fd493a8fd16617af7210c3f5fbd">parcReadOnlyBuffer_GetUint32</a> (PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:a75131fd493a8fd16617af7210c3f5fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the single <code>uint32_t</code> at the current buffer position.  <a href="#a75131fd493a8fd16617af7210c3f5fbd">More...</a><br /></td></tr>
<tr class="separator:a75131fd493a8fd16617af7210c3f5fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41114a8fe1910a815b19e463a0e011fa"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a41114a8fe1910a815b19e463a0e011fa">parcReadOnlyBuffer_GetUint64</a> (PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:a41114a8fe1910a815b19e463a0e011fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the unsigned 64-bit value in network order at the buffer's current position, and then increment the position by 8.  <a href="#a41114a8fe1910a815b19e463a0e011fa">More...</a><br /></td></tr>
<tr class="separator:a41114a8fe1910a815b19e463a0e011fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32359641ba1f804eb48661f06bdc121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="parc___hash_code_8h.html#a6a9149819db0ee85c2f8dc474c006705">PARCHashCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#ad32359641ba1f804eb48661f06bdc121">parcReadOnlyBuffer_HashCode</a> (const PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:ad32359641ba1f804eb48661f06bdc121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hash code value for the given instance.  <a href="#ad32359641ba1f804eb48661f06bdc121">More...</a><br /></td></tr>
<tr class="separator:ad32359641ba1f804eb48661f06bdc121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc69fa964112297c1323176738ed7bdd"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#afc69fa964112297c1323176738ed7bdd">parcReadOnlyBuffer_ToString</a> (const PARCReadOnlyBuffer *buffer)</td></tr>
<tr class="memdesc:afc69fa964112297c1323176738ed7bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a null-terminated C string containing the bytes of the given <code>PARCReadOnlyBuffer</code>.  <a href="#afc69fa964112297c1323176738ed7bdd">More...</a><br /></td></tr>
<tr class="separator:afc69fa964112297c1323176738ed7bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d536269768e0adefdbd16d4b9d62bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___read_only_buffer_8h.html#a71d536269768e0adefdbd16d4b9d62bb">parcReadOnlyBuffer_Display</a> (const PARCReadOnlyBuffer *buffer, int indentation)</td></tr>
<tr class="memdesc:a71d536269768e0adefdbd16d4b9d62bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a human readable representation of the given <code>PARCReadOnlyBuffer</code>.  <a href="#a71d536269768e0adefdbd16d4b9d62bb">More...</a><br /></td></tr>
<tr class="separator:a71d536269768e0adefdbd16d4b9d62bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a96d6f03abb7c55a53ad7ed8b1cd64a88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCReadOnlyBuffer* parcReadOnlyBuffer_Acquire </td>
          <td>(</td>
          <td class="paramtype">const PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the number of references to a <code>PARCReadOnlyBuffer</code>. </p>
<p>Note that new <code>PARCReadOnlyBuffer</code> is not created, only that the given <code>PARCReadOnlyBuffer</code> reference count is incremented. Discard the reference by invoking <code>parcBuffer_Release</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input <code>PARCReadOnlyBuffer</code> pointer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    PARCReadOnlyBuffer *handle = parcReadOnlyBuffer_Acquire(roBuffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ...</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcReadOnlyBuffer_Release(&amp;handle);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="adc28820e8b78321659d98fdfc4c19f1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCByteArray* parcReadOnlyBuffer_Array </td>
          <td>(</td>
          <td class="paramtype">const PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the <a class="el" href="">PARCByteArray</a> that backs this buffer. </p>
<p>If this <code>PARCReadOnlyBuffer</code> has a capacity of zero, there is no array of bytes and this function returns NULL.</p>
<p>Modifications to the <code>PARCByteArray</code> will cause the returned array's content to be modified, and vice versa.</p>
<p>The caller must obtain its own reference to the <code>PARCByteArray</code> if it intends to store it elsewhere.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the <code>PARCByteArray</code> for the given <code>PARCReadOnlyBuffer</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t array[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(array, 10, 0, 10);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    PARCByteArray *byteArray = parcReadOnlyBuffer_Array(roBuffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ...</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcByteArray_Release(&amp;byteArray);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0c569ce138aa1854ca1d4b4045e9074d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t parcReadOnlyBuffer_ArrayOffset </td>
          <td>(</td>
          <td class="paramtype">const PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the offset within this buffer's backing <a class="el" href="">PARCByteArray</a> of the first element. </p>
<p>Buffer position <em>p</em> corresponds to array index <em>p + arrayOffset()</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset within this <code>PARCReadOnlyBuffer</code>'s array of the first element of the buffer</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t array[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(array, 10, 0, 10);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    size_t arrayOffset = parcReadOnlyBuffer_ArrayOffset(buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // offset will be 0 since the contents of the buffer start at the beginning</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a25d6ab918f02b0a7dabb8cf3b2e35de6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t parcReadOnlyBuffer_Capacity </td>
          <td>(</td>
          <td class="paramtype">const PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this buffer's capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCReadOnlyBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given buffer's capacity.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t array[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(array, 10, 0, 10);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    size_t capacity = parcReadOnlyBuffer_Capacity(roBuffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // capacity will be 10</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    ...</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aec31d44124e22f3c258ceb89899c7860"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCReadOnlyBuffer* parcReadOnlyBuffer_Clear </td>
          <td>(</td>
          <td class="paramtype">PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the given buffer: The position is set to zero, the limit is set to the capacity, and the mark is invalidated. </p>
<p>The mark is made invalid and any subsequent operation on the resulting <code>PARCBuffer</code> that requires the mark will abort until the mark is set again via <code>parcReadOnlyBuffer_Mark</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A pointer to the <code>PARCReadOnlyBuffer</code> instance to be modified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <code>buffer</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    parcReadOnlyBuffer_Clear(buffer);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3c5440e5af26d0b31984399978e1effd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCReadOnlyBuffer* parcReadOnlyBuffer_Copy </td>
          <td>(</td>
          <td class="paramtype">const PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>original</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of the given <code>PARCReadOnlyBuffer</code>. </p>
<p>A new buffer is created as a complete copy of the original.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">original</td><td>A <code>PARCReadOnlyBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>PARCReadOnlyBuffer</code> instance which is an identical, independent copy of the original.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t array[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(array, 10, 0, 10);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    PARCReadOnlyBuffer *copy = parcReadOnlyBuffer_Copy(roBuffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    if (parcReadOnlyBuffer_Equals(roBuffer, copy)) {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        printf(&quot;ROBuffers are equal\n&quot;);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    }</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    parcReadOnlyBuffer_Release(&amp;copy);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___read_only_buffer_8h.html#a318303e625fdf7786e1a0580f57fa6e7" title="Determine if two PARCReadOnlyBuffer instances are equal. ">parcReadOnlyBuffer_Equals</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5873c15cfe65b95677ea4f18204178a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCReadOnlyBuffer* parcReadOnlyBuffer_Create </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instance of <code>PARCBuPARCReadOnlyBuffer</code> referencing the content of the given <a class="el" href="">PARCBuffer</a>. </p>
<p>A reference to the content of the given <code>PARCBuffer</code> is acquired.</p>
<p>The new buffer's position, limit, capacity and mark will be the same as the given <code>PARCBuffer</code>.</p>
<p>If capacity is zero, the buffer contains no underlying byte array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointed to a valid <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>PARCReadOnlyBuffer</code> pointer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a71d536269768e0adefdbd16d4b9d62bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parcReadOnlyBuffer_Display </td>
          <td>(</td>
          <td class="paramtype">const PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indentation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a human readable representation of the given <code>PARCReadOnlyBuffer</code>. </p>
<p>Print on standard output a human readable representation of the given <code>PARCReadOnlyBuffer</code> indented by the level indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to the <code>PARCReadOnlyBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indentation</td><td>The number of tabs by which to indent the output strings.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    parcReadOnlyBuffer_Display(buffer, 0);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a318303e625fdf7786e1a0580f57fa6e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parcReadOnlyBuffer_Equals </td>
          <td>(</td>
          <td class="paramtype">const PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two <code>PARCReadOnlyBuffer</code> instances are equal. </p>
<p>The following equivalence relations on non-null <code>PARCReadOnlyBuffer</code> instances are maintained:</p>
<ul>
<li>It is reflexive: for any non-null reference value x, <code>parcReadOnlyBuffer_Equals(x, x)</code> must return true.</li>
<li>It is symmetric: for any non-null reference values x and y, <code>parcReadOnlyBuffer_Equals(x, y)</code> must return true if and only if <code>parcReadOnlyBuffer_Equals(y x)</code> returns true.</li>
<li>It is transitive: for any non-null reference values x, y, and z, if <code>parcReadOnlyBuffer_Equals(x, y)</code> returns true and <code>parcReadOnlyBuffer_Equals(y, z)</code> returns true, then <code>parcReadOnlyBuffer_Equals(x, z)</code> must return true.</li>
<li>It is consistent: for any non-null reference values x and y, multiple invocations of <code>parcReadOnlyBuffer_Equals(x, y)</code> consistently return true or consistently return false.</li>
<li>For any non-null reference value x, <code>parcReadOnlyBuffer_Equals(x, NULL)</code> must return false.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A pointer to a <code>PARCReadOnlyBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>A pointer to a <code>PARCReadOnlyBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>PARCReadOnlyBuffer</code> x and y are equal. </dd>
<dd>
false <code>PARCReadOnlyBuffer</code> x and y are not equal.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t array[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCReadOnlyBuffer *roBuffer1 = parcReadOnlyBuffer_Create(array, 10, 0, 10);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    PARCReadOnlyBuffer *roBuffer2 = parcReadOnlyBuffer_Create(array, 10, 0, 10);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    if (parcReadOnlyBuffer_Equals(roBuffer1, roBuffer2)) {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        printf(&quot;ROBuffers are equal\n&quot;);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    } else {</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;        printf(&quot;ROBuffers are NOT equal\n&quot;);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    }</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="af186ebea64d92ca9d2d3cd2508a69b89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCReadOnlyBuffer* parcReadOnlyBuffer_GetArray </td>
          <td>(</td>
          <td class="paramtype">PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the limit to the current position, then set the position to zero. </p>
<p>If the mark is defined, it is invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>The <code>PARCReadOnlyBuffer</code> pointer to be modified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same value as <code>buffer</code></dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;   {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;       PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;       parcBuffer_PutByte(buffer, &#39;X&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;       PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  </div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;       parcReadOnlyBuffer_Flip(roBuffer);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;       uint8_t actual = parcReadOnlyBuffer_GetUint8(roBuffer);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  </div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;       ...</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  </div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;       parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;       parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   }</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  /</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;PARCReadOnlyBuffer *parcReadOnlyBuffer_Flip(PARCReadOnlyBuffer *buffer);</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;/**</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160; * Get the single uint8_t at the index specified.</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  </div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; * @param [in] buffer A `PARCReadOnlyBuffer` pointer.</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; * @param [in] index The index from which to retrieve the single byte in the buffer.</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  </div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160; * @return The uint8_t value at the specified index</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  </div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; * Example:</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160; * @code</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160; * {</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; *     PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160; *     parcBuffer_PutByte(buffer, &#39;X&#39;);</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160; *     PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  </div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; *     uint8_t byte = parcReadOnlyBuffer_GetAtIndex(roBuffer, 0);</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  </div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160; *     ...</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  </div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160; *     parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160; *     parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160; * }</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160; */</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;uint8_t parcReadOnlyBuffer_GetAtIndex(const PARCReadOnlyBuffer *buffer, size_t index);</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;/**</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160; * Read an array of length bytes from the given PARCReadOnlyBuffer, copying them to an array.</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  </div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160; * The buffer&#39;s position is incremented by @p length.</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  </div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160; * @param [in] buffer The `PARCReadOnlyBuffer` containing the `uint8_t` value.</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160; * @param [out] array The `uint8_t` array to receive @p length bytes.</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160; * @param [in] length The number of `uint8_t` elements to get..</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  </div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160; * @return The given `PARCReadOnlyBuffer`.</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  </div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160; * Example:</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160; * @code</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160; * {</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160; *     PARCBuffer *buffer = parcBuffer_Allocate(5);</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160; *     parcBuffer_PutUint8(buffer, &#39;A&#39;);</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160; *     parcBuffer_PutUint8(buffer, &#39;B&#39;);</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160; *     parcBuffer_PutUint8(buffer, &#39;C&#39;);</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160; *     PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  </div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160; *     uint8_t array[3];</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160; *     parcReadOnlyBuffer_GetArray(roBuffer, 3, array);</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160; *     // array[0] == &#39;A&#39;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160; *     // array[1] == &#39;B&#39;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160; *     // array[2] == &#39;C&#39;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160; * }</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160; * </div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___read_only_buffer_8h.html#a913e6dc56f8c73d3df521135a154b4d6" title="Return a pointer to memory that can be cast to a specific type. ">parcReadOnlyBuffer_Overlay</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3fce2c9d774159fb9dfff895b9c0e3c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t parcReadOnlyBuffer_GetUint16 </td>
          <td>(</td>
          <td class="paramtype">PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the single <code>uint16_t</code> at the current buffer position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>uint16_t</code> value at the current position.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint16(buffer, 0x1234);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcReadOnlyBuffer_Flip(roBuffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    uint16_t actual = parcReadOnlyBuffer_GetUint16(roBuffer);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a75131fd493a8fd16617af7210c3f5fbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t parcReadOnlyBuffer_GetUint32 </td>
          <td>(</td>
          <td class="paramtype">PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the single <code>uint32_t</code> at the current buffer position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>uint32_t</code> value at the current position.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint32(buffer, 0x12345678);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcReadOnlyBuffer_Flip(roBuffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    uint32_t actual = parcReadOnlyBuffer_GetUint32(roBuffer);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a41114a8fe1910a815b19e463a0e011fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t parcReadOnlyBuffer_GetUint64 </td>
          <td>(</td>
          <td class="paramtype">PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the unsigned 64-bit value in network order at the buffer's current position, and then increment the position by 8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>The <code>PARCReadOnlyBuffer</code> containing the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>uint64_t</code> at the buffer's current position.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(sizeof(uint64_t));</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint64(buffer, 0x1234567812345678);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_Flip(buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    PARCReadOnlyBuffer *readOnly = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    uint64_t actual = parcReadOnlyBuffer_GetUint64(&amp;readOnly);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a02d23a06e0adb3e7aab3f0ab0d72e88d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t parcReadOnlyBuffer_GetUint8 </td>
          <td>(</td>
          <td class="paramtype">PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the single <code>uint8_t</code> at the current buffer position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>uint8_t</code> value at the current position.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutByte(buffer, &#39;X&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcReadOnlyBuffer_Flip(roBuffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    uint8_t actual = parcReadOnlyBuffer_GetUint8(roBuffer);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad32359641ba1f804eb48661f06bdc121"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="parc___hash_code_8h.html#a6a9149819db0ee85c2f8dc474c006705">PARCHashCode</a> parcReadOnlyBuffer_HashCode </td>
          <td>(</td>
          <td class="paramtype">const PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a hash code value for the given instance. </p>
<p>The general contract of <code>HashCode</code> is:</p>
<p>Whenever it is invoked on the same instance more than once during an execution of an application, the <a class="el" href="parc___read_only_buffer_8h.html#ad32359641ba1f804eb48661f06bdc121">parcReadOnlyBuffer_HashCode</a> function must consistently return the same value, provided no information used in a corresponding <a class="el" href="parc___read_only_buffer_8h.html#a318303e625fdf7786e1a0580f57fa6e7">parcReadOnlyBuffer_Equals()</a> comparisons on the instance is modified.</p>
<p>This value need not remain consistent from one execution of an application to another execution of the same application. If two instances are equal according to the <a class="el" href="parc___read_only_buffer_8h.html#a318303e625fdf7786e1a0580f57fa6e7">parcReadOnlyBuffer_Equals</a> method, then calling the <a class="el" href="parc___read_only_buffer_8h.html#ad32359641ba1f804eb48661f06bdc121">parcReadOnlyBuffer_HashCode</a> method on each of the two instances must produce the same integer result.</p>
<p>It is not required that if two instances are unequal according to the <a class="el" href="parc___read_only_buffer_8h.html#a318303e625fdf7786e1a0580f57fa6e7">parcReadOnlyBuffer_Equals()</a> function, then calling the <a class="el" href="parc___read_only_buffer_8h.html#ad32359641ba1f804eb48661f06bdc121">parcReadOnlyBuffer_HashCode()</a> method on each of the two objects must produce distinct integer results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to the <code>PARCReadOnlyBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hashcode for the given instance.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint32_t hashValue = parcReadOnlyBuffer_HashCode(buffer);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___read_only_buffer_8h.html#a318303e625fdf7786e1a0580f57fa6e7" title="Determine if two PARCReadOnlyBuffer instances are equal. ">parcReadOnlyBuffer_Equals</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afbf5417af111da7901cda352758f0aa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parcReadOnlyBuffer_HasRemaining </td>
          <td>(</td>
          <td class="paramtype">const PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether there are any elements between the current position and the limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if, and only if, there is at least one element remaining in this <code>PARCReadOnlyBuffer</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    parcReadOnlyBuffer_SetPosition(buffer, 5);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    bool remaining = parcReadOnlyBuffer_HasRemaining(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    // remaining is true, since #remaining = 5</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a6b24a3b835275a610c7693ea49fc422b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t parcReadOnlyBuffer_Limit </td>
          <td>(</td>
          <td class="paramtype">const PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the given <code>PARCReadOnlyBuffer</code>'s limit. </p>
<p>A buffer's limit is the index of the first element that should not be read or written. A buffer's limit is never negative and is never greater than its capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given <code>PARCReadOnlyBuffer</code>'s limit.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    size_t limit = parcReadOnlyBuffer_Limit(roBuffer);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    // limit will be 10</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3eea1d4192f49da754d0e4a2d099916e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCReadOnlyBuffer* parcReadOnlyBuffer_Mark </td>
          <td>(</td>
          <td class="paramtype">PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this buffer's mark at its position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given <code>PARCReadOnlyBuffer</code> pointer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcReadOnlyBuffer_Mark(roBuffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // since the position was 0, the mark remains at 0</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a913e6dc56f8c73d3df521135a154b4d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* parcReadOnlyBuffer_Overlay </td>
          <td>(</td>
          <td class="paramtype">PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to memory that can be cast to a specific type. </p>
<p>This does not guarantee proper memory alignment. It is possible to obtain a pointer to memory that cannot be accessed as integer or other types because of CPU memory alignment requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of bytes to advance the buffer's position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL A pointer to memory.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    char *expected = &quot;Hello World&quot;;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    struct timeval theTime = { .tv_sec = 123, .tv_usec = 456};</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(sizeof(uint16_t) + strlen(expected) + sizeof(theTime));</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    parcBuffer_PutUint16(buffer, strlen(expected));</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcBuffer_PutUint8(buffer, expected, strlen(expected));</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcBuffer_PutUint8(buffer, &amp;theTime, sizeof(theTime));</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    parcBuffer_Flip();</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    uint16_t length = parcBuffer_GetUint16(buffer);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    char *actual = parcReadOnlyBuffer_Overlay(roBuffer, length);</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    struct timeval *tm = parcReadOnlyBuffer_Overlay(roBuffer, sizeof(struct timeval));</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a258dc7660b1640b40a161d2be5eace8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t parcReadOnlyBuffer_Position </td>
          <td>(</td>
          <td class="paramtype">const PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the given <code>PARCReadOnlyBuffer</code>'s position. </p>
<p>A buffer's position is the index of the next element to be read or written. A buffer's position is never negative and is never greater than its limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given <code>PARCReadOnlyBuffer</code>'s position.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    size_t position = parcReadOnlyBuffer_Position(roBuffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // position is zero since the position of the underlying buffer is also 0</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a8828c20c01777b8502abe6f4ff9c206c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parcReadOnlyBuffer_Release </td>
          <td>(</td>
          <td class="paramtype">PARCReadOnlyBuffer **&#160;</td>
          <td class="paramname"><em>bufferPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a <code>PARCReadOnlyBuffer</code> reference. </p>
<p>Only the last invocation where the reference count is decremented to zero, will actually destroy the <code>PARCReadOnlyBuffer</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bufferPtr</td><td>Pointer to the <code>PARCReadOnlyBuffer</code> instance to be released.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="af15d1a5859b9b87f9905bbfe7a45df00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t parcReadOnlyBuffer_Remaining </td>
          <td>(</td>
          <td class="paramtype">const PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements between the current position and the limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements remaining in this <code>PARCReadOnlyBuffer</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    parcReadOnlyBuffer_SetPosition(buffer, 5);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcReadOnlyBuffer_Remaining(buffer); // Returns 5.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7bc7e08324fdf8277a198b7523727e7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCReadOnlyBuffer* parcReadOnlyBuffer_Reset </td>
          <td>(</td>
          <td class="paramtype">PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the given <code>PARCReadOnlyBuffer</code>'s position to the previously-marked position. </p>
<p>Invoking this method neither changes nor invalidates the mark's value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given <code>PARCReadOnlyBuffer</code> pointer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint8(buffer, (uint8_t)&#39;A&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    parcReadOnlyBuffer_Reset(roBuffer);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a6869292dc3368d740a53e5f73ab83ab4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCReadOnlyBuffer* parcReadOnlyBuffer_Rewind </td>
          <td>(</td>
          <td class="paramtype">PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewinds this <code>PARCReadOnlyBuffer</code>: The position is set to zero and the mark is invalidated. </p>
<p>The mark is made invalid and any subsequent operation on the resulting <a class="el" href="">PARCBuffer</a> that requires the mark will abort until the mark is set again via <a class="el" href="parc___buffer_8h.html#a70834200bfdeb0f8aea80c49e7ad711e">parcBuffer_Mark</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given <code>PARCReadOnlyBuffer</code> pointer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint8(buffer, (uint8_t)&#39;A&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    parcReadOnlyBuffer_Rewind(roBuffer);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a5bc5e29414e66c562cdbd520429d7b7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCReadOnlyBuffer* parcReadOnlyBuffer_SetLimit </td>
          <td>(</td>
          <td class="paramtype">PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this <code>PARCReadOnlyBuffer</code>'s limit. </p>
<p>If the position is larger than the new limit then it is set to the new limit.</p>
<p>If the mark is defined and larger than the new limit then the mark is invalidated and any subsequent operation that requires the mark will abort until the mark is set again via <a class="el" href="parc___read_only_buffer_8h.html#a3eea1d4192f49da754d0e4a2d099916e">parcReadOnlyBuffer_Mark()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newLimit</td><td>The new limit value; must be no larger than this <code>PARCReadOnlyBuffer</code>'s capacity</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given <code>PARCReadOnlyBuffer</code> pointer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcReadOnlyBuffer_SetLimit(roBuffer, 8);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // the limit is now 8, but the capacity is 10</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a5efd568d40d46f93c0069e3403ec00d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCReadOnlyBuffer* parcReadOnlyBuffer_SetPosition </td>
          <td>(</td>
          <td class="paramtype">PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the given <code>PARCReadOnlyBuffer</code>'s position. </p>
<p>A buffer's position is the index of the next element to be read or written. A buffer's position is never negative and is never greater than its limit.</p>
<p>If the mark is defined and larger than the new position then the mark is invalidated and any subsequent operation on the resulting <code>PARCReadOnlyBuffer</code> that requires the mark will abort until the mark is set again via <code>parcReadOnlyBuffer_Mark</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPosition</td><td>The value of the new position which must be less than or equal to the buffer's current limit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given <code>PARCReadOnlyBuffer</code>'s position.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCReadOnlyBuffer *buffer = parcReadOnlyBuffer_Create(parcBuffer_Allocate(10));</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcReadOnlyBuffer_SetPosition(buffer, 5);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcReadOnlyBuffer_Remaining(buffer); // Returns 5.</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="afc69fa964112297c1323176738ed7bdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* parcReadOnlyBuffer_ToString </td>
          <td>(</td>
          <td class="paramtype">const PARCReadOnlyBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a null-terminated C string containing the bytes of the given <code>PARCReadOnlyBuffer</code>. </p>
<p>The string consists of the bytes from the current position of the buffer to its limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A <code>PARCReadOnlyBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL Cannot allocate memory. </dd>
<dd>
non-NULL A pointer to a null-terminated C string that must be deallocated via <a class="el" href="">parcMemory_Deallocate</a>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    char *string = parcReadOnlyBuffer_ToString(buffer);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcMemory_Deallocate((void **)&amp;string);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a587c7811d8650888fd517d4108d60b90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCReadOnlyBuffer* parcReadOnlyBuffer_Wrap </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instance of <code>PARCReadOnlyBuffer</code> using program supplied memory. </p>
<p>The new buffer will be backed by the given byte array. Modifications to the array will be visible through the buffer.</p>
<p>The new buffer's capacity will be <code>arrayLength</code>, its position will be <code>position</code>, its limit will be <code>limit</code>, and its mark will be undefined.</p>
<p>Its backing array will be the given array, and its array offset will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>A pointer to a memory array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLength</td><td>The length, in <code>uint8_t</code> units, of the memory array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The initial value for the buffer's position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit</td><td>The initial value for the buffer's limit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>PARCReadOnlyBuffer</code> pointer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t array[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCReadOnlyBuffer *roBuffer = parcReadOnlyBuffer_Create(array, 10, 0, 10);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    parcReadOnlyBuffer_Release(&amp;roBuffer);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
<!--END GENERATE_TREEVIEW-->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/>
  <div class="container footer">
Copyright  2008-2016, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC)<br/>
Thu Aug 25 2016 12:44:00
<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
//<![CDATA[
var sc_project=11084416; 
var sc_invisible=0;
var sc_security="641a5c50"; 
var scJsHost = (("https:" == document.location.protocol) ?  "https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" + scJsHost+ "statcounter.com/counter/counter_xhtml.js'></"+"script>");
//]]>
</script>
<noscript>
<div class="statcounter">
<a title="shopify site analytics" href="http://statcounter.com/shopify/" class="statcounter">
<img class="statcounter" style="width: 2;" src="//c.statcounter.com/11084416/0/641a5c50/0/" alt="statcounter" />
</a></div></noscript>
  </div>
<!-- End of StatCounter Code for Default Guide -->
  </div>
</body>
</html>
